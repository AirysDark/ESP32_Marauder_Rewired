name: Build-with-configs (JSON)

on:
  workflow_dispatch:
    inputs:
      board_flag:
        description: "Board flag (default: MARAUDER_V7)"
        required: false
        default: "MARAUDER_V7"
      board_label:
        description: "Optional board_label override"
        required: false
        default: ""

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python deps
        run: |
          pip install --upgrade pip
          pip install pyserial

      - name: Debug repo layout
        run: |
          pwd
          ls -la
          ls -la scaffold || true
          ls -la scaffold/configs || true
          ls -la scaffold/configs/boards || true
          sed -n '1,120p' scaffold/configs/boards/boards_manifest.json || true

      - name: Export board env from JSON manifest
        run: |
          echo "BOARD_FLAG=${{ github.event.inputs.board_flag }}" >> $GITHUB_ENV
          echo "BOARD_LABEL=${{ github.event.inputs.board_label }}" >> $GITHUB_ENV
          python3 scaffold/tools/export_env_from_json.py >> $GITHUB_ENV 2>> exporter.err || true
          echo "----- exporter stderr -----"
          cat exporter.err || true

      - name: Ensure FLAG present (fallback to input or MARAUDER_V7)
        run: |
          if [ -z "$FLAG" ]; then
            if [ -n "${{ github.event.inputs.board_flag }}" ]; then
              echo "FLAG=${{ github.event.inputs.board_flag }}" >> $GITHUB_ENV
            else
              echo "FLAG=MARAUDER_V7" >> $GITHUB_ENV
            fi
          fi

      - name: Ensure FQBN set (fbqn fallback)
        run: |
          if [ -z "$FQBN" ] && [ -n "$FBQN" ]; then
            echo "FQBN=$FBQN" >> $GITHUB_ENV
          fi

      - name: Last-resort FQBN mapping
        run: |
          if [ -z "$FQBN" ]; then
            case "$FLAG" in
              MARAUDER_V7|MARAUDER_V6|MARAUDER_V6_1|MARAUDER_KIT|MARAUDER_MINI)
                echo "FQBN=esp32:esp32:d32:PartitionScheme=min_spiffs" >> $GITHUB_ENV ;;
              MARAUDER_CARDPUTER|MARAUDER_MULTIBOARD_S3)
                echo "FQBN=esp32:esp32:esp32s3:PartitionScheme=min_spiffs,FlashSize=8M" >> $GITHUB_ENV ;;
              MARAUDER_REV_FEATHER|MARAUDER_FLIPPER)
                echo "FQBN=esp32:esp32:esp32s2:PartitionScheme=min_spiffs,FlashSize=4M,PSRAM=enabled" >> $GITHUB_ENV ;;
              *)
                echo "::error::FQBN not found for FLAG='$FLAG' and no fallback rule defined."
                exit 1;;
            esac
            echo "::notice::Applied last-resort FQBN mapping for $FLAG"
          fi

      - name: Assert FQBN present
        run: |
          if [ -z "$FQBN" ]; then
            echo "::error::FQBN is empty after exporter+fallback ? check boards_manifest (fqbn/fbqn)."
            exit 1
          fi

      - name: Dump resolved env (debug)
        run: |
          env | sort | grep -E '^(FLAG|BOARD_LABEL|FQBN|CORE_VERSION|FILESYSTEM|PARTITION|ADDR|DISPLAY_|LIBS_|DEFINES_BASE)=' || true

      - name: Setup Arduino CLI
        uses: arduino/setup-arduino-cli@v2
        with:
          version: 0.35.3

      - name: Configure ESP32 board manager index
        run: |
          arduino-cli config init
          arduino-cli config set board_manager.additional_urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json
          arduino-cli core update-index --additional-urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json

      - name: Force core version 2.0.11
        run: echo "CORE_VERSION=2.0.11" >> $GITHUB_ENV

      - name: Install ESP32 core (with retry)
        run: |
          set -e
          for i in 1 2 3; do
            arduino-cli core install esp32:esp32@${CORE_VERSION} \
              --additional-urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json && break || {
                echo "Install attempt $i failed; retrying in 5s..."
                sleep 5
              }
          done
          arduino-cli core list

      - name: Clean conflicting libraries (XPT touch/TFT leftovers)
        run: |
          LIBDIR="$HOME/Arduino/libraries"
          mkdir -p "$LIBDIR"
          cd "$LIBDIR"
          rm -rf XPT2049Touch XPT2046_Touchscreen TFT_eSPI || true

      - name: Install required libraries
        run: |
          set -e
          NIMBLE_VER="${LIBS_NIMBLE_VERSION:-$LIBS_NIMBLE_VER}"
          ESPASYNC_REPO="${LIBS_ESP_ASYNC_REPO:-bigbrodude6119/ESPAsyncWebServer}"
          ESPASYNC_VER="${LIBS_ESP_ASYNC_VERSION:-$LIBS_ESP_ASYNC_VER}"
          echo "Resolved: NIMBLE_VER='${NIMBLE_VER}'  ESPASYNC_REPO='${ESPASYNC_REPO}'  ESPASYNC_VER='${ESPASYNC_VER}'"
          if [ -n "$NIMBLE_VER" ]; then
            arduino-cli lib install "NimBLE-Arduino@${NIMBLE_VER}"
          else
            echo "::warning::NimBLE version empty; installing latest."
            arduino-cli lib install NimBLE-Arduino
          fi
          LIBDIR="$HOME/Arduino/libraries"
          mkdir -p "$LIBDIR"
          cd "$LIBDIR"
          rm -rf ESPAsyncWebServer || true
          if [ -n "$ESPASYNC_VER" ]; then
            git clone --depth 1 --branch "$ESPASYNC_VER" "https://github.com/${ESPASYNC_REPO}" ESPAsyncWebServer
          else
            echo "::warning::ESPAsyncWebServer version empty; using default branch."
            git clone --depth 1 "https://github.com/${ESPASYNC_REPO}" ESPAsyncWebServer
          fi

      # ---------- Stage sketch ----------
      - name: Prepare Sketch Folder
        id: prep
        run: |
          SKETCH_DIR="${PWD}/_build/esp32_marauder_rewired"
          rm -rf "$SKETCH_DIR"; mkdir -p "$SKETCH_DIR"
          SRC_INO="$(ls scaffold/*.ino | head -n 1)"
          cp "$SRC_INO" "$SKETCH_DIR/esp32_marauder_rewired.ino"
          cp -r scaffold/* "$SKETCH_DIR/" || true
          echo "sketch_dir=$SKETCH_DIR" >> $GITHUB_OUTPUT

      - name: Assert sketch prepared
        run: |
          test -f "${{ steps.prep.outputs.sketch_dir }}/esp32_marauder_rewired.ino" || { echo "::error ::prepared .ino missing"; ls -la "${{ steps.prep.outputs.sketch_dir }}" || true; exit 1; }

      # ---------- Autogen headers into the staged dir ----------
      - name: Generate config.h (JSON-driven)
        run: |
          python3 scaffold/tools/gen_user_config.py \
            --boards-json scaffold/configs/boards/boards_manifest.json \
            --defines-json scaffold/configs/defines/build_defines.json \
            --modules-json scaffold/configs/modules/modules_presets.json \
            --board-flag "$BOARD_FLAG" \
            --board-label "$BOARD_LABEL" \
            --out "${{ steps.prep.outputs.sketch_dir }}/.autogen/config.h"

      - name: Generate TFT_eSPI header (serial-only safe)
        run: |
          mkdir -p "${{ steps.prep.outputs.sketch_dir }}/.tft_setup"
          python3 scaffold/tools/gen_tft_setup_json.py \
            --boards-json scaffold/configs/boards/boards_manifest.json \
            --displays-json scaffold/configs/displays/display_presets.json \
            --pins-json scaffold/configs/pins/pin_presets.json \
            --board-label "$BOARD_LABEL" \
            --board-flag "$BOARD_FLAG" \
            --model "${DISPLAY_MODEL}" \
            --tft-enabled "${DISPLAY_ENABLED}" \
            --out-dir "${{ steps.prep.outputs.sketch_dir }}/.tft_setup"

      - name: Ensure registry generator exists (guard)
        run: |
          set -e
          mkdir -p scaffold/tools
          if [ ! -f scaffold/tools/gen_registry_from_modules.py ]; then
            cat > scaffold/tools/gen_registry_from_modules.py <<'PY'
          #!/usr/bin/env python3
          import json, os, sys, re, argparse
          
          def norm_id(s: str) -> str:
              s = (s or "").strip()
              if not s: return ""
              s = s.replace("-", "_").replace(" ", "_")
              s = re.sub(r"[^a-zA-Z0-9_]", "", s)
              if re.match(r"^\d", s): s = "_" + s
              return s
          
          def load_modules(path: str):
              with open(path, "r", encoding="utf-8") as f:
                  data = json.load(f)
              mods = []
              if isinstance(data, list):
                  mods = [m for m in data if isinstance(m, dict)]
              elif isinstance(data, dict):
                  if isinstance(data.get("modules"), list):
                      mods = [m for m in data["modules"] if isinstance(m, dict)]
                  else:
                      for k, v in data.items():
                          if isinstance(v, dict):
                              vv = dict(v); vv.setdefault("id", k); mods.append(vv)
              out = []
              for m in mods:
                  mid = norm_id(m.get("id") or m.get("name") or m.get("module") or "")
                  if not mid:
                      mid = norm_id(f'{m.get("category","")}_{m.get("name","")}')
                  if not mid: continue
                  if str(m.get("enabled", True)).lower() in ("false","0","no"): continue
                  out.append({"id": mid, "name": m.get("name", mid)})
              return out
          
          def main():
              ap = argparse.ArgumentParser()
              ap.add_argument("--modules-json", required=True)
              ap.add_argument("--out-cpp", required=True)
              ap.add_argument("--out-h", required=False)
              ap.add_argument("--ns", default="RegistryInit")
              args = ap.parse_args()
          
              mods = load_modules(args.modules_json)
              os.makedirs(os.path.dirname(args.out_cpp), exist_ok=True)
              if args.out_h:
                  os.makedirs(os.path.dirname(args.out_h), exist_ok=True)
                  with open(args.out_h, "w", encoding="utf-8") as h:
                      h.write("// Autogenerated: registered_modules.h\n#pragma once\n\n")
                      if mods:
                          h.write("/* Enabled modules (sanitized IDs): */\n")
                          for m in mods: h.write(f"//  - {m['id']}\n")
                      else:
                          h.write("// (no enabled modules discovered)\n")
          
              with open(args.out_cpp, "w", encoding="utf-8") as w:
                  w.write("// Autogenerated: RegistryInit.autogen.cpp\n")
                  w.write("// DO NOT EDIT BY HAND ? generated from modules_presets.json\n\n")
                  w.write('#include "RegistryInit.h"\n\n')
                  for m in mods:
                      fid = m["id"]
                      w.write(f'extern "C" void register_{fid}(void) __attribute__((weak));\n')
                  w.write("\n")
                  w.write(f"void {args.ns}::init() {{\n")
                  if not mods:
                      w.write("  // No modules enabled; nothing to register.\n")
                  else:
                      for m in mods:
                          fid = m["id"]
                          w.write(f"  if (register_{fid}) register_{fid}();\n")
                  w.write("}\n")
          
              print(f"Generated {args.out_cpp} with {len(mods)} module calls.")
              if args.out_h: print(f"Generated {args.out_h}")
          
          if __name__ == '__main__':
              main()
          PY
                      chmod +x scaffold/tools/gen_registry_from_modules.py
                      echo "::notice::Created scaffold/tools/gen_registry_from_modules.py on runner (guard)."
                    fi
          
                - name: Verify registry generator path
                  run: |
                    ls -la scaffold/tools
                    sed -n '1,40p' scaffold/tools/gen_registry_from_modules.py

      # ---------- Registry: autogen calls from modules_presets ----------
      - name: Autogen RegistryInit from modules
        run: |
          OUTCPP="${{ steps.prep.outputs.sketch_dir }}/RegistryInit.autogen.cpp"
          OUTHDR="${{ steps.prep.outputs.sketch_dir }}/.autogen/registered_modules.h"
          python3 scaffold/tools/gen_registry_from_modules.py \
            --modules-json scaffold/configs/modules/modules_presets.json \
            --out-cpp "$OUTCPP" \
            --out-h "$OUTHDR"
          echo "Generated:"
          ls -la "$OUTCPP" "$OUTHDR" || true

      # ---------- Partitions / filesystem ----------
      - name: Resolve FS/Partition and install custom CSV if present
        id: fs
        shell: bash
        run: |
          set -euo pipefail
          FS_IN="${FILESYSTEM:-}"
          PART_IN="${PARTITION:-}"
          CORE_VER="${CORE_VERSION:-2.0.11}"

          CORE_PART_DIR="$HOME/.arduino15/packages/esp32/hardware/esp32/${CORE_VER}/tools/partitions"

          FS="$FS_IN"
          PART="${PART_IN}"
          if [ -n "$PART" ]; then PART="${PART%.csv}.csv"; fi

          if [ -n "$PART" ]; then
            SRC="${GITHUB_WORKSPACE}/partitions/$PART"
            if [ -f "$SRC" ]; then
              mkdir -p "$CORE_PART_DIR"
              cp -f "$SRC" "$CORE_PART_DIR/$PART"
              echo "Installed custom partition CSV to $CORE_PART_DIR/$PART"
            fi
          fi

          echo "fs=$FS"   >> $GITHUB_OUTPUT
          echo "partition=$PART" >> $GITHUB_OUTPUT
          echo "Filesystem: ${FS:-<core default>}"
          echo "Partition:  ${PART:-<core default>}"

      # ---------- Compile ----------
      - name: Compile (Arduino CLI)
        working-directory: ${{ steps.prep.outputs.sketch_dir }}
        shell: bash
        env:
          EXTRA_FLAGS: -I${{ steps.prep.outputs.sketch_dir }}/.tft_setup -I${{ steps.prep.outputs.sketch_dir }}/.autogen ${DEFINES_BASE}
        run: |
          set -euo pipefail
          if [ -z "${FQBN:-}" ]; then
            echo "::error::FQBN is empty at compile time; check earlier steps."
            exit 1
          fi

          FS="${{ steps.fs.outputs.fs }}"
          PART="${{ steps.fs.outputs.partition }}"
          PART_PROP=""
          if [ -n "$PART" ]; then
            PART_PROP="--build-property build.partitions=${PART%.csv}"
          fi

          echo "FQBN:       $FQBN"
          echo "Sketch dir: $(pwd)"
          echo "Filesystem: ${FS:-<default>}"
          echo "Partition:  ${PART:-<default>}"
          ls -la; ls -la .tft_setup || true; ls -la .autogen || true

          arduino-cli compile \
            --fqbn "$FQBN" \
            --warnings none \
            --export-binaries \
            --build-property "compiler.cpp.extra_flags=${EXTRA_FLAGS}" \
            ${PART_PROP} \
            --output-dir "$GITHUB_WORKSPACE/build_out" \
            .

      - name: Upload firmware artifact
        uses: actions/upload-artifact@v4
        with:
          name: fw-${{ env.FLAG }}-${{ env.CORE_VERSION }}-${{ env.DISPLAY_MODEL || 'serial' }}
          path: build_out
